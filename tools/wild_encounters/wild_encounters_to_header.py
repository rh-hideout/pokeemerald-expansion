import json
import re

TIME_OF_DAY_ENCOUNTERS_PAT = re.compile(r'\s*#\s*define OW_TIME_OF_DAY_ENCOUNTERS\s+(\w+)')
TIME_OF_DAY_DISABLE_FALLBACK_PAT = re.compile(r'\s*#\s*define OW_TIME_OF_DAY_DISABLE_FALLBACK\s+(\w+)')
TIME_OF_DAY_FALLBACK_PAT = re.compile(r'\s*#\s*define OW_TIME_OF_DAY_FALLBACK\s+(\w+)')

class Config:
    def __init__(self, config_file_name, rtc_constants_file_name, encounters_json_data):
        self.times_of_day = None
        self.mon_types = None
        self.time_encounters = None
        self.disable_time_fallback = None
        self.time_fallback = None

        self.ParseTimeEnum(rtc_constants_file_name)
        if self.times_of_day == None:
            raise Exception(f"Failed to parse 'enum TimeOfDay' in '{rtc_constants_file_name}'")

        with open(config_file_name, 'r') as config_file:
            lines = config_file.readlines()
            for line in lines:
                self.ParseTimeConfig(line)
        
        if self.time_encounters == None:
            raise Exception("OW_TIME_OF_DAY_ENCOUNTERS not defined.")
        if self.disable_time_fallback == None:
            raise Exception("OW_TIME_OF_DAY_DISABLE_FALLBACK not defined.")
        if self.time_fallback == None:
            raise Exception("OW_TIME_OF_DAY_FALLBACK not defined.")
    
    def ParseTimeEnum(self, rtc_constants_file_name):
        with open(rtc_constants_file_name, 'r') as rtc_constants_file:
            DEFAULT_TIME_PAT = re.compile(r"enum\s+TimeOfDay\s*\{(?P<rtc_val>[\s*\w+,\=\d*]+)\s*\}\s*\;")
            file = rtc_constants_file.read()

            m = DEFAULT_TIME_PAT.search(file)
            if m:
                txt = m.group('rtc_val')
                time_constants = re.findall(r'TIME_\w+', txt)
                self.times_of_day = {
                    constant: constant.removeprefix("TIME_").title().replace("_", "")
                    for constant in time_constants
                }

    def ParseMonTypes(self, encounters_json_data):
        for group in encounters_json_data["wild_encounter_groups"]:
            if "fields" in group:
                for field in group["fields"]:
                    field_type = field["type"]
                    if not self.mon_types:
                        self.mon_types = []
                    self.mon_types.append(field_type)

    def ParseTimeConfig(self, line):
        m = TIME_OF_DAY_ENCOUNTERS_PAT.match(line)
        if m:
            self.time_encounters = m.group(1) in ["TRUE", "1"]

        m = TIME_OF_DAY_DISABLE_FALLBACK_PAT.match(line)
        if m:
            self.disable_time_fallback = m.group(1) in ["TRUE", "1"]

        m = TIME_OF_DAY_FALLBACK_PAT.match(line)
        if m:
            self.time_fallback = m.group(1)


class WildEncounterAssembler:
    def __init__(self, output_file, json_data, config):
        self.output_file = output_file
        self.json_data = json_data
        self.config = config
        self.encounter_types = set()

    def WriteLine(self, line="", indents = 0):
        self.output_file.write(4 * indents * " " + line + "\n")

    def WriteHeader(self):
        self.WriteLine("//")
        self.WriteLine("// DO NOT MODIFY THIS FILE! It is auto-generated by tools/wild_encounters/wild_encounters_to_header.py")
        self.WriteLine("//")
        self.output_file.write("\n\n")

    def WriteMonInfos(self, name, mons, encounter_rate):
        self.WriteLine(f"const struct WildPokemonInfo {name}Info =")
        self.WriteLine("{")
        self.WriteLine(f".encounterRate = {encounter_rate},", 1)
        self.WriteLine(f".numSlots = {len(mons)},", 1)
        self.WriteLine(f".totalWeight = {sum(mon.get('weight', 1) for mon in mons)},", 1)
        self.WriteLine(".wildPokemon =", 1)
        self.WriteLine("{", 1)

        for mon in mons:
            species = mon["species"]
            min_level = mon.get("min_level", 2)
            max_level = mon.get("max_level", 100)
            weight = mon.get("weight", 1)
            self.WriteLine(f"{{ .minLevel={min_level}, .maxLevel={max_level}, .species={species}, .weight={weight} }},", 2)

        self.WriteLine("},", 1)
        self.WriteLine("};")
        self.WriteLine()

    def WriteTerminator(self):
        self.WriteLine("{", 1)
        self.WriteLine(".mapGroup = MAP_GROUP(MAP_UNDEFINED),", 2)
        self.WriteLine(".mapNum = MAP_NUM(MAP_UNDEFINED),", 2)
        self.WriteLine(".encounterTypes =  {{ 0 }},", 2)
        self.WriteLine("},", 1)

    def WritePokemonHeaders(self, headers):
        label = headers["label"]
        self.WriteLine(f"const struct WildPokemonHeader {label}[] =")
        self.WriteLine("{")
        for label, map_data in headers["data"].items():
            self.WriteLine()
            encounter_data = map_data["encounters"]
            map_group = map_data["mapGroup"]
            map_num = map_data["mapNum"]
            version = "EMERALD"
            if "FireRed" in label:
                version = "FIRERED"
            elif "LeafGreen" in label:
                version = "LEAFGREEN"
            
            self.WriteLine(f"#ifdef {version}")

            self.WriteLine("{", 1)
            self.WriteLine(f".mapGroup = {map_group},", 2)
            self.WriteLine(f".mapNum = {map_num},", 2)
            if not encounter_data:
                continue
            self.WriteLine(".encounterTypes =", 2)
            self.WriteLine("{", 2)
            for time in self.config.times_of_day:
                if time not in encounter_data:
                    continue
                if not encounter_data[time]:
                    self.WriteLine(f"[{time}] = {{ 0 }},", 3)
                    continue
                self.WriteLine(f"[{time}] =", 3)
                self.WriteLine("{", 3)

                for encounter_type, encounter_table_name in encounter_data[time].items():
                    member_name = encounter_type.title().replace("_", "")
                    member_name = member_name[0].lower() + member_name[1:] + "Info"
                    self.WriteLine(f".{member_name} = &{encounter_table_name},", 4)

                self.WriteLine("},", 3)
            
            self.WriteLine("},", 2)
            self.WriteLine("},", 1)
            self.WriteLine(f"#endif")
        self.WriteTerminator()
        self.WriteLine("};")


    def WriteEncounters(self):
        wild_encounter_groups = self.json_data["wild_encounter_groups"]
        for wild_encounter_group in wild_encounter_groups:
            headers = {}
            headers["label"] = wild_encounter_group["label"]
            headers["data"] = {}
            for_maps = wild_encounter_group.get("for_maps", False)
            map_num_counter = 1
            encounters = wild_encounter_group["encounters"]

            for map_encounters in encounters:
                map_group = "0"
                map_num = str(map_num_counter)
                if for_maps:
                    map_name = map_encounters["map"]
                    map_group = f"MAP_GROUP({map_name})"
                    map_num = f"MAP_NUM({map_name})"
                map_num_counter += 1
                base_label = map_encounters["base_label"]
                shared_label = base_label
                time = self.config.time_fallback

                for time_const, time_label in self.config.times_of_day.items():
                    if base_label.endswith(time_label):
                        time = time_const
                        shared_label = base_label.removesuffix('_' + time_label)

                if shared_label not in headers["data"]:
                    headers["data"][shared_label] = {
                        "mapGroup": map_group,
                        "mapNum": map_num,
                        "encounters": {}
                    }
                if time in headers["data"][shared_label]:
                    print(f"Warning: ignoring redefinition of encounter data for label {shared_label} and time {time}! (Entry has {base_label=}.)")
                    continue
                encounter_table_names = {}

                version = "EMERALD"
                if "FireRed" in shared_label:
                    version = "FIRERED"
                elif "LeafGreen" in shared_label:
                    version = "LEAFGREEN"

                self.WriteLine(f"#ifdef {version}")
                for encounter_type, mons_entry in map_encounters["encounter_sets"].items():
                    encounter_rate = mons_entry["encounter_rate"]
                    mons = mons_entry["mons"]

                    mon_array_name = base_label + "_" + encounter_type.title().replace("_", "")
                    self.WriteMonInfos(mon_array_name, mons, encounter_rate)
                    encounter_table_names[encounter_type] = mon_array_name + "Info"

                headers["data"][shared_label]["encounters"][time] = encounter_table_names
                self.WriteLine(f"#endif")

            self.WritePokemonHeaders(headers)


def ConvertToHeaderFile(json_data):
    with open('src/data/wild_encounters.h', 'w') as output_file:
        config = Config('include/config/overworld.h', 'include/constants/rtc.h', json_data)
        assembler = WildEncounterAssembler(output_file, json_data, config)
        assembler.WriteHeader()
        assembler.WriteEncounters()

def main():
    with open('src/data/wild_encounters.json', 'r') as json_file:
        json_data = json.load(json_file)
        ConvertToHeaderFile(json_data)
        

if __name__ == '__main__':
    main()
