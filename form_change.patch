diff --git a/include/battle_anim.h b/include/battle_anim.h
index bf716e6869..45b21a682a 100644
--- a/include/battle_anim.h
+++ b/include/battle_anim.h
@@ -78,7 +78,6 @@ extern u8 gBattleAnimTarget;
 extern u16 gAnimBattlerSpecies[MAX_BATTLERS_COUNT];
 extern u8 gAnimCustomPanning;
 extern u16 gAnimMoveIndex;
-extern bool8 gAnimPendingBattlerSpriteUpdate;

 void ClearBattleAnimationVars(void);
 void DoMoveAnim(enum Move move);
diff --git a/include/battle_util.h b/include/battle_util.h
index b2f709af28..1511265d5b 100644
--- a/include/battle_util.h
+++ b/include/battle_util.h
@@ -49,7 +49,6 @@ enum FieldEffectCases

 enum AbilityEffect
 {
-    ABILITYEFFECT_ON_SWITCHIN,
     ABILITYEFFECT_ENDTURN,
     ABILITYEFFECT_MOVE_END_ATTACKER,
     ABILITYEFFECT_COLOR_CHANGE, // Color Change / Berserk / Anger Shell
@@ -57,6 +56,7 @@ enum AbilityEffect
     ABILITYEFFECT_IMMUNITY,
     ABILITYEFFECT_SYNCHRONIZE,
     ABILITYEFFECT_ATK_SYNCHRONIZE,
+    ABILITYEFFECT_FORM_CHANGE_ON_HIT,
     ABILITYEFFECT_MOVE_END_OTHER,
     ABILITYEFFECT_MOVE_END_FOES_FAINTED, // Moxie-like abilities / Battle Bond / Magician

@@ -64,6 +64,8 @@ enum AbilityEffect
     ABILITYEFFECT_TERA_SHIFT,
     ABILITYEFFECT_NEUTRALIZINGGAS,
     ABILITYEFFECT_UNNERVE,
+    ABILITYEFFECT_ON_SWITCHIN,
+    ABILITYEFFECT_SWITCH_IN_FORM_CHANGE,
     ABILITYEFFECT_COMMANDER, // Commander / Hospitality / Costar
     ABILITYEFFECT_ON_WEATHER,
     ABILITYEFFECT_ON_TERRAIN,
@@ -137,7 +139,6 @@ enum MoveSuccessOrder
     CANCELER_EXPLOSION,
     CANCELER_MULTIHIT_MOVES,
     CANCELER_MULTI_TARGET_MOVES,
-    CANCELER_FORM_CHANGE_DURING_MOVE,
     CANCELER_END,
 };

diff --git a/include/constants/battle_end_turn.h b/include/constants/battle_end_turn.h
index 5ff2d5cb3f..ff8cf46409 100644
--- a/include/constants/battle_end_turn.h
+++ b/include/constants/battle_end_turn.h
@@ -49,7 +49,7 @@ enum EndTurnResolutionOrder
     ENDTURN_TERRAIN,
     ENDTURN_THIRD_EVENT_BLOCK,
     ENDTURN_EMERGENCY_EXIT_4,
-    ENDTURN_FORM_CHANGE_ABILITIES,
+    ENDTURN_FORM_CHANGE,
     ENDTURN_EJECT_PACK,
     ENDTURN_DYNAMAX,
     ENDTURN_TRAINER_A_SLIDES,
diff --git a/include/constants/battle_move_resolution.h b/include/constants/battle_move_resolution.h
index 384e0d08a1..60bbaec152 100644
--- a/include/constants/battle_move_resolution.h
+++ b/include/constants/battle_move_resolution.h
@@ -17,6 +17,7 @@ enum MoveEndState
     MOVEEND_RAGE,
     MOVEEND_SYNCHRONIZE_TARGET,
     MOVEEND_ABILITIES,
+    MOVEEND_FORM_CHANGE_ON_HIT, // Disguise / Gulp Missile
     MOVEEND_ABILITIES_ATTACKER,
     MOVEEND_STATUS_IMMUNITY_ABILITIES, // TODO: Do berries come before????
     MOVEEND_SYNCHRONIZE_ATTACKER,
diff --git a/include/constants/battle_switch_in.h b/include/constants/battle_switch_in.h
index 3a3084472b..5a75b3c1fd 100644
--- a/include/constants/battle_switch_in.h
+++ b/include/constants/battle_switch_in.h
@@ -8,6 +8,7 @@ enum SwitchInEvents
     SWITCH_IN_EVENTS_NEUTRALIZING_GAS,
     SWITCH_IN_EVENTS_UNNERVE,
     SWITCH_IN_EVENTS_FIRST_BLOCK,
+    SWITCH_IN_EVENTS_FORM_CHANGE,
     SWITCH_IN_EVENTS_SECOND_BLOCK,
     SWITCH_IN_EVENTS_WHITE_HERB,
     SWITCH_IN_EVENTS_OPPORTUNIST,
diff --git a/src/battle_anim.c b/src/battle_anim.c
index 76966743aa..674db15ee1 100644
--- a/src/battle_anim.c
+++ b/src/battle_anim.c
@@ -121,7 +121,6 @@ EWRAM_DATA u8 gBattleAnimTarget = 0;
 EWRAM_DATA u16 gAnimBattlerSpecies[MAX_BATTLERS_COUNT] = {0};
 EWRAM_DATA u8 gAnimCustomPanning = 0;
 EWRAM_DATA static bool8 sAnimHideHpBoxes = FALSE;
-EWRAM_DATA bool8 gAnimPendingBattlerSpriteUpdate = FALSE;

 #include "data/battle_anim.h"

diff --git a/src/battle_end_turn.c b/src/battle_end_turn.c
index 62d511cee6..0301d1b688 100644
--- a/src/battle_end_turn.c
+++ b/src/battle_end_turn.c
@@ -1315,11 +1315,19 @@ static bool32 CanBattlerEndTurnFormChange(u32 battler, enum Ability ability)
 {
     u32 species = gBattleMons[battler].species;

-    return (GetBattleFormChangeTargetSpecies(battler, FORM_CHANGE_BATTLE_HP_PERCENT_TURN_END, ability) != species
-        || GetBattleFormChangeTargetSpecies(battler, FORM_CHANGE_BATTLE_TURN_END, ability) != species);
+
+    if (GetBattleFormChangeTargetSpecies(battler, FORM_CHANGE_BATTLE_TURN_END, ability) != species
+     && TryBattleFormChange(battler, FORM_CHANGE_BATTLE_TURN_END))
+        return TRUE;
+
+    if (GetBattleFormChangeTargetSpecies(battler, FORM_CHANGE_BATTLE_HP_PERCENT_TURN_END, ability) != species
+     && TryBattleFormChange(battler, FORM_CHANGE_BATTLE_HP_PERCENT_TURN_END))
+        return TRUE;
+
+    return FALSE;
 }

-static bool32 HandleEndTurnFormChangeAbilities(u32 battler)
+static bool32 HandleEndTurnFormChange(u32 battler)
 {
     bool32 effect = FALSE;

@@ -1327,8 +1335,18 @@ static bool32 HandleEndTurnFormChangeAbilities(u32 battler)

     gBattleStruct->eventState.endTurnBattler++;

-    if (CanBattlerEndTurnFormChange(battler, ability) && AbilityBattleEffects(ABILITYEFFECT_ENDTURN, battler, ability, MOVE_NONE, TRUE))
+    if (CanBattlerEndTurnFormChange(battler, ability))
+    {
+        gBattleScripting.battler = battler;
+        gBattleScripting.abilityPopupOverwrite = ability; // To prevent the new form's ability from pop up
+        if (ability == ABILITY_POWER_CONSTRUCT) // Special animation
+            BattleScriptExecute(BattleScript_PowerConstruct);
+        else if (ability == ABILITY_HUNGER_SWITCH)
+            BattleScriptExecute(BattleScript_BattlerFormChangeEnd3NoPopup);
+        else
+            BattleScriptExecute(BattleScript_BattlerFormChangeEnd2); // Generic animation
         effect = TRUE;
+    }

     return effect;
 }
@@ -1472,7 +1490,7 @@ static bool32 (*const sEndTurnEffectHandlers[])(u32 battler) =
     [ENDTURN_TERRAIN] = HandleEndTurnTerrain,
     [ENDTURN_THIRD_EVENT_BLOCK] = HandleEndTurnThirdEventBlock,
     [ENDTURN_EMERGENCY_EXIT_4] = HandleEndTurnEmergencyExit,
-    [ENDTURN_FORM_CHANGE_ABILITIES] = HandleEndTurnFormChangeAbilities,
+    [ENDTURN_FORM_CHANGE] = HandleEndTurnFormChange,
     [ENDTURN_EJECT_PACK] = HandleEndTurnEjectPack,
     [ENDTURN_DYNAMAX] = HandleEndTurnDynamax,
     [ENDTURN_TRAINER_A_SLIDES] = HandleEndTurnTrainerASlides,
diff --git a/src/battle_move_resolution.c b/src/battle_move_resolution.c
index da44bc1070..e07b7dbc96 100644
--- a/src/battle_move_resolution.c
+++ b/src/battle_move_resolution.c
@@ -231,6 +231,17 @@ static enum MoveEndResult MoveEnd_Abilities(void)
     return result;
 }

+static enum MoveEndResult MoveEnd_FormChangeOnHit(void)
+{
+    enum MoveEndResult result = MOVEEND_STEP_CONTINUE;
+
+    if (AbilityBattleEffects(ABILITYEFFECT_FORM_CHANGE_ON_HIT, gBattlerTarget, GetBattlerAbility(gBattlerTarget), 0, TRUE))
+        result = MOVEEND_STEP_RUN_SCRIPT;
+
+    gBattleScripting.moveendState++;
+    return result;
+}
+
 static enum MoveEndResult MoveEnd_AbilitiesAttacker(void)
 {
     enum MoveEndResult result = MOVEEND_STEP_CONTINUE;
@@ -1715,6 +1726,7 @@ static enum MoveEndResult (*const sMoveEndHandlers[])(void) =
     [MOVEEND_RAGE] = MoveEnd_Rage,
     [MOVEEND_SYNCHRONIZE_TARGET] = MoveEnd_SynchronizeTarget,
     [MOVEEND_ABILITIES] = MoveEnd_Abilities,
+    [MOVEEND_FORM_CHANGE_ON_HIT] = MoveEnd_FormChangeOnHit,
     [MOVEEND_ABILITIES_ATTACKER] = MoveEnd_AbilitiesAttacker,
     [MOVEEND_STATUS_IMMUNITY_ABILITIES] = MoveEnd_StatusImmunityAbilities,
     [MOVEEND_SYNCHRONIZE_ATTACKER] = MoveEnd_SynchronizeAttacker,
diff --git a/src/battle_script_commands.c b/src/battle_script_commands.c
index 94146d3bfc..b7526b90f8 100644
--- a/src/battle_script_commands.c
+++ b/src/battle_script_commands.c
@@ -1955,20 +1955,21 @@ static void Cmd_waitanimation(void)
 {
     CMD_ARGS();

-    if (gBattleControllerExecFlags == 0 && gBattleStruct->battlerKOAnimsRunning == 0)
+    if (gBattleControllerExecFlags != 0 || gBattleStruct->battlerKOAnimsRunning != 0)
+        return;
+
+    #if T_SHOULD_RUN_MOVE_ANIM
+    gCountAllocs = FALSE;
+    #endif
+
+    if (TryBattleFormChange(gBattlerAttacker, FORM_CHANGE_BATTLE_HP_PERCENT_DURING_MOVE))
     {
-#if T_SHOULD_RUN_MOVE_ANIM
-        gCountAllocs = FALSE;
-#endif
-        if (gAnimPendingBattlerSpriteUpdate)
-        {
-            gAnimPendingBattlerSpriteUpdate = FALSE;
-            PlayAnimation(gBattlerAttacker, B_ANIM_FORM_CHANGE_INSTANT, NULL, cmd->nextInstr);
-        }
-        else
-        {
-            gBattlescriptCurrInstr = cmd->nextInstr;
-        }
+        // Only execute B_ANIM_FORM_CHANGE_INSTANT for those who have changed forms
+        PlayAnimation(gBattlerAttacker, B_ANIM_FORM_CHANGE_INSTANT, NULL, cmd->nextInstr);
+    }
+    else
+    {
+        gBattlescriptCurrInstr = cmd->nextInstr;
     }
 }

diff --git a/src/battle_switch_in.c b/src/battle_switch_in.c
index b5596bb66b..b6ba61c0a8 100644
--- a/src/battle_switch_in.c
+++ b/src/battle_switch_in.c
@@ -92,6 +92,16 @@ bool32 DoSwitchInEvents(void)
         gBattleStruct->switchInBattlerCounter = 0;
         gBattleStruct->eventState.switchIn++;
         break;
+    case SWITCH_IN_EVENTS_FORM_CHANGE:
+        while (gBattleStruct->switchInBattlerCounter < gBattlersCount)
+        {
+            battler = gBattlersBySpeed[gBattleStruct->switchInBattlerCounter++];
+            if (AbilityBattleEffects(ABILITYEFFECT_SWITCH_IN_FORM_CHANGE, battler, calcValues.abilities[battler], 0, gBattleStruct->battlerState[battler].switchIn))
+                return TRUE;
+        }
+        gBattleStruct->switchInBattlerCounter = 0;
+        gBattleStruct->eventState.switchIn++;
+        break;
     case SWITCH_IN_EVENTS_SECOND_BLOCK:
         while (gBattleStruct->switchInBattlerCounter < gBattlersCount)
         {
diff --git a/src/battle_util.c b/src/battle_util.c
index c381eee930..560f1e6a50 100644
--- a/src/battle_util.c
+++ b/src/battle_util.c
@@ -3115,17 +3115,6 @@ static enum MoveCanceler CancelerMultiTargetMoves(struct BattleContext *ctx)
     return MOVE_STEP_SUCCESS;
 }

-static enum MoveCanceler CancelerFormChangeDuringAnim(struct BattleContext *ctx)
-{
-    // Gulp Missile changes
-    if (TryBattleFormChange(gBattlerAttacker, FORM_CHANGE_BATTLE_HP_PERCENT_DURING_MOVE))
-    {
-        // Only execute B_ANIM_FORM_CHANGE_INSTANT for those who have changed forms
-        gAnimPendingBattlerSpriteUpdate = TRUE;
-    }
-    return MOVE_STEP_SUCCESS;
-}
-
 static enum MoveCanceler (*const sMoveSuccessOrderCancelers[])(struct BattleContext *ctx) =
 {
     [CANCELER_CLEAR_FLAGS] = CancelerClearFlags,
@@ -3164,7 +3153,6 @@ static enum MoveCanceler (*const sMoveSuccessOrderCancelers[])(struct BattleCont
     [CANCELER_EXPLOSION] = CancelerExplosion,
     [CANCELER_MULTIHIT_MOVES] = CancelerMultihitMoves,
     [CANCELER_MULTI_TARGET_MOVES] = CancelerMultiTargetMoves,
-    [CANCELER_FORM_CHANGE_DURING_MOVE] = CancelerFormChangeDuringAnim,
 };

 enum MoveCanceler AtkCanceler_MoveSuccessOrder(struct BattleContext *ctx)
@@ -4309,7 +4297,7 @@ u32 AbilityBattleEffects(enum AbilityEffect caseID, u32 battler, enum Ability ab
     u32 side = 0;
     u32 i = 0, j = 0;
     u32 partner = 0;
-    enum Ability abilityForm;
+    u32 speciesForm = SPECIES_NONE;

     if (gBattleTypeFlags & BATTLE_TYPE_SAFARI)
         return 0;
@@ -4875,17 +4863,15 @@ u32 AbilityBattleEffects(enum AbilityEffect caseID, u32 battler, enum Ability ab
         default:
             break;
         }
-
-        abilityForm = gLastUsedAbility;
-        // Handle ability form changes upon switch-in.
-        if (!effect && TryBattleFormChange(battler, FORM_CHANGE_BATTLE_HP_PERCENT_SEND_OUT))
+        break;
+    case ABILITYEFFECT_SWITCH_IN_FORM_CHANGE:
+        if (TryBattleFormChange(battler, FORM_CHANGE_BATTLE_HP_PERCENT_SEND_OUT))
         {
             // To prevent the new form's ability from pop up
-            gBattleScripting.abilityPopupOverwrite = abilityForm;
+            gBattleScripting.abilityPopupOverwrite = ability;
             BattleScriptCall(BattleScript_BattlerFormChange);
             effect++;
         }
-
         break;
     case ABILITYEFFECT_ENDTURN:
         if (IsBattlerAlive(battler))
@@ -5068,16 +5054,6 @@ u32 AbilityBattleEffects(enum AbilityEffect caseID, u32 battler, enum Ability ab
                     effect++;
                 }
                 break;
-            case ABILITY_HUNGER_SWITCH:
-                if (!gBattleMons[battler].volatiles.transformed
-                 && GetActiveGimmick(battler) != GIMMICK_TERA
-                 && TryBattleFormChange(battler, FORM_CHANGE_BATTLE_TURN_END))
-                {
-                    gBattleScripting.battler = battler;
-                    BattleScriptExecute(BattleScript_BattlerFormChangeEnd3NoPopup);
-                    effect++;
-                }
-                break;
             case ABILITY_CUD_CHEW:
                 if (gBattleMons[battler].volatiles.cudChew == TRUE)
                 {
@@ -5096,20 +5072,6 @@ u32 AbilityBattleEffects(enum AbilityEffect caseID, u32 battler, enum Ability ab
             default:
                 break;
             }
-
-            abilityForm = gLastUsedAbility;
-            // Handle ability form changes at the end of the turn here.
-            if (!effect && TryBattleFormChange(battler, FORM_CHANGE_BATTLE_HP_PERCENT_TURN_END))
-            {
-                gBattleScripting.battler = battler;
-                // To prevent the new form's ability from pop up
-                gBattleScripting.abilityPopupOverwrite = abilityForm;
-                if (gLastUsedAbility == ABILITY_POWER_CONSTRUCT) // Special animation
-                    BattleScriptExecute(BattleScript_PowerConstruct);
-                else
-                    BattleScriptExecute(BattleScript_BattlerFormChangeEnd2); // Generic animation
-                effect++;
-            }
         }
         break;
     case ABILITYEFFECT_COLOR_CHANGE:
@@ -5601,54 +5563,6 @@ u32 AbilityBattleEffects(enum AbilityEffect caseID, u32 battler, enum Ability ab
         default:
             break;
         }
-
-        abilityForm = gLastUsedAbility;
-        u32 speciesForm = gBattleMons[gBattlerTarget].species;
-        // Handle ability form changes when hit by a move here.
-        if (!effect
-            && IsBattlerTurnDamaged(gBattlerTarget)
-            && TryBattleFormChange(battler, FORM_CHANGE_BATTLE_HIT_BY_MOVE_CATEGORY))
-        {
-            gBattleScripting.abilityPopupOverwrite = abilityForm;
-            gBattleScripting.battler = gBattlerTarget;
-
-            switch (abilityForm)
-            {
-            case ABILITY_GULP_MISSILE:
-                if (!gBattleStruct->unableToUseMove
-                && IsBattlerAlive(gBattlerAttacker))
-                {
-                    if (!IsAbilityAndRecord(gBattlerAttacker, GetBattlerAbility(gBattlerAttacker), ABILITY_MAGIC_GUARD))
-                        SetPassiveDamageAmount(gBattlerAttacker, GetNonDynamaxMaxHP(gBattlerAttacker) / 4);
-
-                    switch (speciesForm)
-                    {
-                        case SPECIES_CRAMORANT_GORGING:
-                            BattleScriptCall(BattleScript_GulpMissileGorging);
-                            break;
-                        case SPECIES_CRAMORANT_GULPING:
-                            BattleScriptCall(BattleScript_GulpMissileGulping);
-                            break;
-                        default:
-                            BattleScriptCall(BattleScript_BattlerFormChange); // Fallback
-                            break;
-                    }
-                }
-                break;
-            case ABILITY_DISGUISE:
-                if (GetConfig(CONFIG_DISGUISE_HP_LOSS) >= GEN_8 && ability == ABILITY_DISGUISE)
-                    SetPassiveDamageAmount(gBattlerTarget, GetNonDynamaxMaxHP(gBattlerTarget) / 8);
-                BattleScriptCall(BattleScript_BattlerFormChangeDisguise);
-                break;
-            case ABILITY_ICE_FACE:
-                BattleScriptCall(BattleScript_IceFaceNullsDamage);
-                break;
-            default:
-                BattleScriptCall(BattleScript_BattlerFormChange);
-                break;
-            }
-            effect++;
-        }
         break;
     case ABILITYEFFECT_MOVE_END_ATTACKER: // Same as above, but for attacker
         switch (gLastUsedAbility)
@@ -5708,6 +5622,53 @@ u32 AbilityBattleEffects(enum AbilityEffect caseID, u32 battler, enum Ability ab
             break;
         }
         break;
+    case ABILITYEFFECT_FORM_CHANGE_ON_HIT:
+        speciesForm = gBattleMons[gBattlerTarget].species;
+
+        if (gBattleStruct->unableToUseMove
+         || !IsBattlerTurnDamaged(gBattlerTarget)
+         || !TryBattleFormChange(gBattlerTarget, FORM_CHANGE_BATTLE_HIT_BY_MOVE_CATEGORY))
+            break;
+
+        gBattleScripting.abilityPopupOverwrite = ability;
+        gBattleScripting.battler = battler;
+        effect++;
+
+        switch (ability)
+        {
+        case ABILITY_GULP_MISSILE:
+            if (!IsBattlerAlive(gBattlerAttacker))
+                break;
+
+            if (!IsAbilityAndRecord(gBattlerAttacker, GetBattlerAbility(gBattlerAttacker), ABILITY_MAGIC_GUARD))
+                SetPassiveDamageAmount(gBattlerAttacker, GetNonDynamaxMaxHP(gBattlerAttacker) / 4);
+
+            switch (speciesForm)
+            {
+            case SPECIES_CRAMORANT_GORGING:
+                BattleScriptCall(BattleScript_GulpMissileGorging);
+                break;
+            case SPECIES_CRAMORANT_GULPING:
+                BattleScriptCall(BattleScript_GulpMissileGulping);
+                break;
+            default:
+                BattleScriptCall(BattleScript_BattlerFormChange); // Fallback
+                break;
+            }
+            break;
+        case ABILITY_DISGUISE:
+            if (GetConfig(CONFIG_DISGUISE_HP_LOSS) >= GEN_8 && ability == ABILITY_DISGUISE)
+                SetPassiveDamageAmount(gBattlerTarget, GetNonDynamaxMaxHP(gBattlerTarget) / 8);
+            BattleScriptCall(BattleScript_BattlerFormChangeDisguise);
+            break;
+        case ABILITY_ICE_FACE:
+            BattleScriptCall(BattleScript_IceFaceNullsDamage);
+            break;
+        default:
+            BattleScriptCall(BattleScript_BattlerFormChange);
+            break;
+        }
+        break;
     case ABILITYEFFECT_MOVE_END_OTHER: // Abilities that activate on *another* battler's moveend: Dancer, Soul-Heart, Receiver, Symbiosis
         switch (GetBattlerAbility(battler))
         {
@@ -9956,6 +9917,10 @@ static bool32 CanBattlerFormChange(u32 battler, enum FormChanges method)
         else if (GetActiveGimmick(battler) == GIMMICK_TERA && DoesSpeciesHaveFormChangeMethod(gBattleMons[battler].species, FORM_CHANGE_BATTLE_TURN_END))
             return FALSE;
         break;
+    case FORM_CHANGE_BATTLE_TURN_END:
+        if (GetActiveGimmick(battler) == GIMMICK_TERA)
+            return FALSE;
+        break;
     default:
         break;
     }
diff --git a/test/battle/ability/gulp_missile.c b/test/battle/ability/gulp_missile.c
index 1e0a4817b0..939d6ce376 100644
--- a/test/battle/ability/gulp_missile.c
+++ b/test/battle/ability/gulp_missile.c
@@ -1,7 +1,7 @@
 #include "global.h"
 #include "test/battle.h"

-SINGLE_BATTLE_TEST("(Gulp Missile) If base Cramorant hits target with Surf it transforms into Gulping form if max HP is over 1/2")
+SINGLE_BATTLE_TEST("Gulp Missile: If base Cramorant hits target with Surf it transforms into Gulping form if max HP is over 1/2")
 {
     GIVEN {
         PLAYER(SPECIES_CRAMORANT) { Ability(ABILITY_GULP_MISSILE); }
@@ -17,7 +17,7 @@ SINGLE_BATTLE_TEST("(Gulp Missile) If base Cramorant hits target with Surf it tr
     }
 }

-SINGLE_BATTLE_TEST("(Gulp Missile) If base Cramorant hits target with Surf it transforms into Gorging form if max HP is under 1/2")
+SINGLE_BATTLE_TEST("Gulp Missile: If base Cramorant hits target with Surf it transforms into Gorging form if max HP is under 1/2")
 {
     GIVEN {
         PLAYER(SPECIES_CRAMORANT) { HP(120); MaxHP(250); Ability(ABILITY_GULP_MISSILE); }
@@ -33,7 +33,7 @@ SINGLE_BATTLE_TEST("(Gulp Missile) If base Cramorant hits target with Surf it tr
     }
 }

-SINGLE_BATTLE_TEST("(Gulp Missile) If base Cramorant is under water it transforms into one of its forms")
+SINGLE_BATTLE_TEST("Gulp Missile: If base Cramorant is under water it transforms into one of its forms")
 {
     GIVEN {
         PLAYER(SPECIES_CRAMORANT) { Ability(ABILITY_GULP_MISSILE); }
@@ -50,7 +50,7 @@ SINGLE_BATTLE_TEST("(Gulp Missile) If base Cramorant is under water it transform
     }
 }

-SINGLE_BATTLE_TEST("(Gulp Missile) Power Herb does not prevent Cramaront from transforming")
+SINGLE_BATTLE_TEST("Gulp Missile: Power Herb does not prevent Cramaront from transforming")
 {
     GIVEN {
         PLAYER(SPECIES_CRAMORANT) { Ability(ABILITY_GULP_MISSILE); Item(ITEM_POWER_HERB); }
@@ -67,7 +67,7 @@ SINGLE_BATTLE_TEST("(Gulp Missile) Power Herb does not prevent Cramaront from tr
     }
 }

-SINGLE_BATTLE_TEST("(Gulp Missile) Transformed Cramorant deal 1/4 of damage opposing mon if hit by a damaging move, Gulping also lowers defense")
+SINGLE_BATTLE_TEST("Gulp Missile: Transformed Cramorant deal 1/4 of damage opposing mon if hit by a damaging move, Gulping also lowers defense")
 {
     s16 gulpMissileDamage;

@@ -93,7 +93,7 @@ SINGLE_BATTLE_TEST("(Gulp Missile) Transformed Cramorant deal 1/4 of damage oppo
     }
 }

-SINGLE_BATTLE_TEST("(Gulp Missile) Cramorant in Gorging paralyzes the target if hit by a damaging move")
+SINGLE_BATTLE_TEST("Gulp Missile: Cramorant in Gorging paralyzes the target if hit by a damaging move")
 {
     GIVEN {
         PLAYER(SPECIES_CRAMORANT) { HP(120); MaxHP(250); Ability(ABILITY_GULP_MISSILE); }
@@ -114,7 +114,7 @@ SINGLE_BATTLE_TEST("(Gulp Missile) Cramorant in Gorging paralyzes the target if
     }
 }

-SINGLE_BATTLE_TEST("(Gulp Missile) triggers even if the user is fainted by opposing mon")
+SINGLE_BATTLE_TEST("Gulp Missile: triggers even if the user is fainted by opposing mon")
 {
     GIVEN {
         PLAYER(SPECIES_CRAMORANT) { HP(1); MaxHP(250); Ability(ABILITY_GULP_MISSILE); }
@@ -135,7 +135,7 @@ SINGLE_BATTLE_TEST("(Gulp Missile) triggers even if the user is fainted by oppos
     }
 }

-SINGLE_BATTLE_TEST("(Gulp Missile) Transformed Cramorant Gulping lowers defense but is prevented by stat reduction preventing abilities")
+SINGLE_BATTLE_TEST("Gulp Missile: Transformed Cramorant Gulping lowers defense but is prevented by stat reduction preventing abilities")
 {
     u32 species;
     enum Ability ability;
@@ -162,7 +162,7 @@ SINGLE_BATTLE_TEST("(Gulp Missile) Transformed Cramorant Gulping lowers defense
     }
 }

-SINGLE_BATTLE_TEST("(Gulp Missile) Transformed Cramorant Gulping lowers defense and still triggers other effects after")
+SINGLE_BATTLE_TEST("Gulp Missile: Transformed Cramorant Gulping lowers defense and still triggers other effects after")
 {
     // Make sure attacker and target are correct after triggering the ability
     enum Ability ability;
@@ -225,7 +225,7 @@ SINGLE_BATTLE_TEST("Gulp Missile only changes forms for Cramorant")
     }
 }

-SINGLE_BATTLE_TEST("If Cramorant loses Gulp Missile, it cannot spit out its prey")
+SINGLE_BATTLE_TEST("Gulp Missile: If Cramorant loses Gulp Missile, it cannot spit out its prey")
 {
     GIVEN {
         ASSUME(!gAbilitiesInfo[ABILITY_GULP_MISSILE].cantBeSwapped);
@@ -251,3 +251,4 @@ SINGLE_BATTLE_TEST("If Cramorant loses Gulp Missile, it cannot spit out its prey
         EXPECT_EQ(opponent->species, SPECIES_PIKACHU);
     }
 }
+
